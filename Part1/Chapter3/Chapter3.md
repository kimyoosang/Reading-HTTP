# Chapter1. URL과 리소스

## **3,1 메시지의 흐름**

- HTTP메시지는 HTTP애플리케이션 간에 주고받은 데이터의 블록들이다. 이 데이터의 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다. 이 메시지는 클라이언트, 서버, 프락시 사이를 흐른다
- '인바운드', '아웃바운드', '업스트림', '다운스트림'은 메시지의 방향을 의미하는 용어다

### **3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다**

- HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다. 메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것이고, 모든 처리가 끑난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 아웃바웃드로 이동하는 것이다

### **3.1.2 다운스트림으로 흐르는 메시지**

- HTTP 메시지는 강물과 같이 흐른다. 요청 메시지나 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐른다
- 메시지의 발송자는 수신자의 업스트림이다

## **3.2 메시지의 각 부분**

- HTTP 메시지는 단순한, 데이터의 구조화된 블록이다
- 각 메시지는 클라이언트로부터 요청이나 서버로부터의 응답 중 하나를 포함한다. 메시지는 시작줄, 헤더 블록, 본문 이렇게 세 부분으로 이루너진다. 시작줄은 이것이 어떤 메시지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있다. 본문은 아예 없을 수도 있다
- 시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열이다. 각 줄은 캐리지 리턴과 개행문자로 구성된 두 글자의 문자열로 끝난다. 이 줄바꿈 문자열은 'CRLF'라고 쓴다. HTTP명세에 따른다면 줄바꿈 문자열은 CRLF이지만 견고한 애플리케이션이라면 그냥 개행 문자도 받아들일 수 이썽야 한다는 점을 알아야 한다. 오래되거나 잘못 만들어진 HTTP 애플리케이션들 중에서는 캐리지 리턴과 개행 문자 모두를 항상 전송하지는 않는 것들도 있다
- 엔터티 본문이나 메시지 본문은 단순히 선택적인 데이터 덩어리이다. 시작줄이나 헤더와는 달리, 본문은 텍스트나 이진 데이터를 포함할 수도 있고 그냥 비어있을 수도 있다
- 헤더는 본문에 대한 꽤 많은 정보를 준다. Content-Type 줄은 본문이 무엇인지 말해준다. Content-Length 줄은 본문의 크기를 말해준다

### **3.2.1 메시지 문법**

- 모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다. 요청 메시지는 웹 서버에 어떤 동작을 요구한다. 응답 메시지는 요청의 결과를 클라이언트에게 돌려준다. 요청과 응답 모두 기본적으로 구조가 같다
- 요청 메시지의 형식은 다음과 같다

  ```
  <메서드> <요청 URL> <버전>
  <헤더>

  <엔터티 본문>
  ```

- 응답 메시지의 형식은 다음과 같다

  ```
  <버전> <상태 코드> <사유 구절>
  <헤더>

  <엔터티 본문>
  ```

**메서드**

- 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작이다. 'GET', 'HEAD', 'POST'와 같이 한 단어로 되어 있다

**요청 URL**

- 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소다. 오나전한 URL이 아닌 URL의 경로 구성요소라고 해도, 클라이언트가 서버와 직접 대화하고 있고 경로 구성요소가 리소스를 가리키는 절대 경로이기만 하면 대체로 문제가 없다
- 서버는 URL에서 생략된 호스트/포트가 자신을 가리키는 것으로 간주할 것이다

**버전**

- HTTP 형식은 다음과 같다
  ```
  HTTP/<메이저>.<마이너>
  ```
- 메이저와 마이너는 모두 정수다

**상태 코드**

- 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자다. 각 토드의 첫 번째 자릿수는 상태의 일반적인 분류를 나타낸다

**사유 구절**

- 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구로, 상태 코드 이후부터 줄바꿈 문자열까지 사유 구절이다
- 사유 구절은 오로지 사람에게 읽히기 위한 목적으로만 존재하는 것이다. 에를 들어 'HTTP/1.0 200 NOT OK' 와 'HTTP1.0 200 OK'는 사유 구절이 전혀 달라 보임에도 불구하고 동등하게 성공을 의미하는 것으로 처리되어야 한다

**헤더들**

- 이름, 콜론, 선택적인 공백 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들, 이 헤더의 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다
- HTTP/1.1과 같은 몇몇 버전의 HTTP는 요청이나 응답에 어떤 특정 헤더가 포함되어야만 유효한 것으로 간주한다

**엔터티 본문**

- 엔터티 본문은 임의이ㅡ 데이터 블록을 포함한다. 모든 메시지가 엔터티 본문을 갖는것은 아니므로, 때때로 메시지는 그냥 CRLF으로 끝나게 된다
- 헤더나 엔터티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄(CRLF)로 끝나야 함에 주의하라
- 이와 같이 널리 쓰이지만 규칙을 잘 지키지 않는 구현체와의 호환을 위해, 클라이언트와 서버는 마지막 CRLF없이 끝나는 메시지도 받아들일 수 있어야 한다

### **3.2.2 시작줄**

- 모든 HTTP 메시지는 시작줄로 시작한다. 요청 메시지의 시작줄은 무엇을 해야 하는지 말해준다. 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다

**요청줄**

- 오청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁한다. 요청 메시지의 시작줄, 혹은 요청줄에는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어있다
- 또한 요청줄은 클라이언트가 어떤 HTTP 버전으로 말하고 있는지 서버에게 알려주는 HTTP 버전도 포함한다
- 이 모든 필드는 공백으로 구분된다
- HTTP/1.0 이전에는 요청줄에 HTTP 버전이 들어있을 필요가 없었다

**응답줄**

- 응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다. 응답 메시지의 시작줄 혹은 응답줄에는 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유 구절이 들어있다
- 이 모든 필드는 공백으로 구분도니다
- HTTP/1.0 이전 시절에는 응답에 응답줄이 들어있을 필요가 없었다

**메서드**

- 요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다. 예를 들어 'GET /special/saw-blade.gif HTTP/1.0' 이라는 줄에서 메서드는 GET이다
- HTTP명세는 공통 요청 메서드의 집합을 정의한다
- HTTP는 쉽게 확장할 수 있도록 설계되었기 때문에, 다른 서버는 그들만의 메서드를 추가로 구현했을 수도있다. 이러한 추가 메서드는 HTTP 명세를 확장하는 것이기 때문에 확장 메서드라고 불린다

**상태 코드**

- 메서드가 서버에게 무엇을 해야 하는지 말해주는 것처럼, 상태 코드는 클라이언트에게 무엇이 일어났는지 말해준다. 상태코드는 응답의 시작줄에 위치한다
- 서버는 요청한 리소스가 발견되지 않았거나, 그 리소스에 접근할 권한이 없거나, 어쩌면 그 리소스가 다른 곳으로 옮겨졌다고 알려올 수도 있다
- 상태 코드는 각 응답 메시지의 시작줄에 담겨 반환된다. 숫자로 된 코드와, 문자열로 되어있어서 사람이 이해하기 쉬운 메시지 두 형태 모두로 반환된다. 사유 구절이 사람에게 쉽게 읽히는 한편, 숫자로된 코드는 프로그램이 에러를 처리하기 쉽다
- 상태 코드들은 세 자리 숫자로 된 그들의 코드값을 기준으로 묶인다. 200에서 299까지의 상태코드는 성공을 나타낸다. 300에서 399까지의 코드는 리소스가 옮겨졌음을 뜻한다. 400에서 499까지의 코드는 클라이언트가 뭔가 잘못된 요청을 했음을 의미한다. 500에서 599까지의 코드는 서버에서 뭔가 실패했음을 의미한다

**사유 구절**

- 사유 구절은 응답 시작줄의 마지막 구성요소다. 이것은 상태 코드에 대한 글로 된 설명을 제공한다
- 사유 구절은 상태 코드와 일대일로 대응된다. 사유 구절은, 애플리케이션 개발자들이 그들의 사용자에게 요청 중에 무슨 일이 일어났는지 알려주기 위해 넘겨줄 수 있는, 상태 코드의 사람이 이해하기 쉬운 버전이다
- HTTP 명세는 사유 구절이 어때야 한다는 어떤 엄격한 규칙도 제공하지 않는다

**버전 번호**

- 버전 번호는 HTTP/x,y 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다. 이것은 HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단이 된다
- 버전 번호는 HTTP로 대화하는 애플리케이션들에게 대화 상대의 능력과 메시지의 형식에 대한 단서를 제공해주기 위한 것이다. HTTP 버전 1.1 애플리케이션과 대화하는 HTTP 버전 1.2 애플리케이션은 1.2 버전의 새로운 기능을 사용할 수 없다는 것을 알아야 한다
- 버전 1.1 애플리케이션은 아마도 1.2 버전의 기능을 구현하지 않았을 것이기 때문이다
- 버전 번호는 어떤 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리킨다
- 응답의 프로토콜이 HTTP/1.1 이라는 것은 사실 응답을 보낸 애플리케잇녀이 HTTP/1.1 까지 이해할 수 있음을 의미하는 것이다
- 버전 번호는 분수로 다루어지지 않음에 주의하라. 버전의 각 숫자는 각각 분리된 ㅜㅆ자로 다루어진다. 따라서 어느 쪽이 큰지 HTTP 버전을 비교할 떄 각 숫자는 반드시 따로따로 비교해야 한다

### **3.2.3 헤더**

- 시작줄 다음에는 0개, 1개 혹은 여러 개의 HTTP 헤더가 온다
- HTTP 헤더 릴드는 요청과 응답 메시지에 추가 정보를 더한다. 그들은 기본적으로 이름/값 쌍의 목록이다

**헤더 분류**

- HTTP 헤더 명세는 여러 헤더 필드를 정의한다. 애플리케이션은 또한 자유롭게 자신만의 헤더를 만들어낼 수 있다
- HTTP헤더는 다음과 같이 분류된다
  - 일반헤더
    - 요청과 응답 양쪽에 모두 나타날 수 있음
  - 요청 헤더
    - 요청에 대한 부가 정보를 제공
  - 응답 헤더
    - 응답에 대한 부가 정보를 제공
  - Entity 헤더
    - 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
  - 확장 헤더
    - 명세에 정의되지 않은 새로운 헤더
- 각 HTTP헤더는 간단한 문법을 가진다. 이름, 쉼표, 공백(없어도 된다), 필드 값, CRLF가 순서대로 온다

**헤더를 여러줄로 나누기**

- 긴 헤더 줄은 그들을 여러 줄로 쪼개서 더 릭기 좋게 만들 수 있는데, 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야 한다
  ```
  HTTP/1.0 200 OK
  Content-Type: image/gif
  Content-Length: 8572
  Server: Test Server
    Version 1.0
  ```
- 이 예에서, 응답 메시지는 여러줄로 값이 쪼개진 Server헤더를 포함하고 있다. 그 헤더의 완전한 값은 'Test Server Version 1.0'이다

### **3.2.4 엔터티 본문**

- HTTP 메시지의 세 번째 부분은 선택적인 엔터티 본문이다. 엔터티 본문은 HTTP 메시지의 화물이라고 할 수 있다. 그것들은 HTTP가 수송하도록 설계된 것이다
- HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있다

### **3.23.5 버전 0.9 메시지**

- HTTP 버전 0.9는 HTTP 프로토콜의 초기 버전이다. 그것은 오늘날 HTTP가 갖고있는 요청과 응답 메시지의 시초이지만, 훨씬 단순한 프로토콜로 되어있다
- HTTP/0.9 메시지도 마찬가지로 요청과 응답으로 이루어져있지만, 요청은 그저 메서드와 요청 URL을 갖고 있을 뿐이며, 응답은 오직 엔터티로만 되어있다. 버전 정보도 없고, 상태 코드나 사유 구절도 없으며, 헤더도 포함되어있지 않다
- 이와 같은 지나칠 정도의 단순함 때문에, HTTP/0.9 로는 다양한 상황에 대응할 수 없다
- HTTP/0.9에 대해 설명한 것은, 여전이 그것을 사용하는 클라이언트, 서버, 기타 애플리케이션들이 있개 때문에, 애플리케이션 개발자들이 HTTP/0.9의 제약에 대해 알아둘 수 있게 하기 위함이다
